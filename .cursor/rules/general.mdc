---
description: 
globs: 
alwaysApply: true
---
# Quiet Light Advisor Aptitude Test - Application Documentation

## Table of Contents
1. [Project Overview](mdc:#project-overview)
2. [Technology Stack](mdc:#technology-stack)
3. [Coding Standards](mdc:#coding-standards)
4. [Backend Implementation](mdc:#backend-implementation)
5. [Frontend Implementation](mdc:#frontend-implementation)
6. [Database Migrations](mdc:#database-migrations)

# Backend Implementation Rules

## API Design Principles

### RESTful Endpoints

Follow these patterns for API endpoints:

- Use nouns for resources (e.g., `/users`, `/questions`, `/sessions`)
- Use HTTP methods appropriately:
  - `GET` for retrieving data
  - `POST` for creating resources
  - `PUT` for updating resources (full update)
  - `PATCH` for partial updates
  - `DELETE` for removing resources
- Use nested routes for sub-resources (e.g., `/sessions/:sessionId/questions`)
- Include versioning in the API path (e.g., `/api/v1/users`)

### API Structure

```
/api/v1
├── /auth
│   ├── POST /login
│   ├── POST /logout
│   └── POST /refresh-token
├── /users
│   ├── GET /
│   ├── GET /:id
│   ├── POST /
│   ├── PUT /:id
│   └── DELETE /:id
├── /test-sessions
│   ├── GET /
│   ├── GET /current
│   ├── GET /:id
│   └── POST /
├── /sections
│   ├── GET /:id
│   ├── GET /:id/questions
│   └── POST /:id/answers
└── /questions
    ├── GET /:id
    └── POST /:id/video-response
```

### API Response Structure

Standardize API responses:

```typescript
// Success response
{
  success: true,
  data: {
    // Resource data
  },
  meta: {
    // Pagination, filters, etc.
  }
}

// Error response
{
  success: false,
  error: {
    code: "VALIDATION_ERROR",
    message: "The request was invalid",
    details: [
      {
        field: "email",
        message: "Email is required"
      }
    ]
  }
}
```

### Request Validation

Use Zod for request validation:

```typescript
import { z } from 'zod';
import { Request, Response, NextFunction } from 'express';

// Define validation schema
const loginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
});

// Create validation middleware
export const validateLogin = (req: Request, res: Response, next: NextFunction) => {
  try {
    loginSchema.parse(req.body);
    next();
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        success: false,
        error: {
          code: 'VALIDATION_ERROR',
          message: 'Invalid request data',
          details: error.errors.map(err => ({
            field: err.path.join('.'),
            message: err.message,
          })),
        },
      });
    }
    
    next(error);
  }
};
```

## Database Structure

### Entity Relationship Diagram

```
┌────────────┐       ┌─────────────┐       ┌─────────┐
│    User    │       │ TestSession │       │ Section │
├────────────┤       ├─────────────┤       ├─────────┤
│ _id        │       │ _id         │       │ _id     │
│ email      │       │ user        │─────▶ │ title   │
│ password   │       │ startDate   │       │ desc    │
│ firstName  │       │ endDate     │       │ type    │
│ lastName   │       │ day         │◀────┐ │ time    │
│ role       │◀──────│ status      │     │ │ day     │
└────────────┘       │ currentSec. │─────┘ │ order   │
                     │ sections    │─────▶ └─────────┘
                     │ progress    │             │
                     └─────────────┘             │
                                                 ▼
                                          ┌────────────┐
                     ┌─────────────┐      │  Question  │
                     │   Answer    │      ├────────────┤
                     ├─────────────┤      │ _id        │
                     │ _id         │      │ type       │
                     │ user        │      │ content    │
                     │ question    │◀─────│ options    │
                     │ section     │      │ rubric     │
                     │ session     │      └────────────┘
                     │ value       │
                     │ videoUrl    │
                     │ score       │
                     │ scoredBy    │
                     └─────────────┘
```

### MongoDB Schema Design

Use Mongoose for schema definition:

```typescript
// src/models/User.ts
import mongoose, { Document, Schema } from 'mongoose';
import bcrypt from 'bcrypt';

export interface IUser extends Document {
  email: string;
  password: string;
  firstName: string;
  lastName: string;
  role: 'candidate' | 'admin';
  comparePassword(candidatePassword: string): Promise<boolean>;
  // other fields...
}

const UserSchema = new Schema<IUser>({
  email: {
    type: String,
    required: [true, 'Email is required'],
    unique: true,
    lowercase: true,
    trim: true,
  },
  password: {
    type: String,
    required: [true, 'Password is required'],
    minlength: [8, 'Password must be at least 8 characters'],
    select: false, // Don't include by default in queries
  },
  firstName: {
    type: String,
    required: [true, 'First name is required'],
    trim: true,
  },
  lastName: {
    type: String,
    required: [true, 'Last name is required'],
    trim: true,
  },
  role: {
    type: String,
    enum: ['candidate', 'admin'],
    default: 'candidate',
  },
}, {
  timestamps: true, // Adds createdAt and updatedAt
});

// Pre-save hook to hash password
UserSchema.pre('save', async function(next) {
  // Only hash the password if it's modified
  if (!this.isModified('password')) return next();
  
  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error as Error);
  }
});

// Method to compare passwords
UserSchema.methods.comparePassword = async function(candidatePassword: string): Promise<boolean> {
  return bcrypt.compare(candidatePassword, this.password);
};

export const User = mongoose.model<IUser>('User', UserSchema);

// src/models/TestSession.ts
import mongoose, { Document, Schema, Types } from 'mongoose';

export interface ITestSession extends Document {
  user: Types.ObjectId;
  startDate: Date;
  endDate?: Date;
  day: 1 | 2;
  status: 'pending' | 'in-progress' | 'completed';
  currentSection?: Types.ObjectId;
  sections: Types.ObjectId[];
  progress: {
    sectionsCompleted: number;
    totalSections: number;
  };
  // other fields...
}

const TestSessionSchema = new Schema<ITestSession>({
  user: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true,
  },
  startDate: {
    type: Date,
    default: Date.now,
  },
  endDate: {
    type: Date,
  },
  day: {
    type: Number,
    enum: [1, 2],
    required: true,
  },
  status: {
    type: String,
    enum: ['pending', 'in-progress', 'completed'],
    default: 'pending',
  },
  currentSection: {
    type: Schema.Types.ObjectId,
    ref: 'Section',
  },
  sections: [{
    type: Schema.Types.ObjectId,
    ref: 'Section',
  }],
  progress: {
    sectionsCompleted: {
      type: Number,
      default: 0,
    },
    totalSections: {
      type: Number,
      default: 0,
    },
  },
}, {
  timestamps: true,
});

export const TestSession = mongoose.model<ITestSession>('TestSession', TestSessionSchema);

// src/models/Section.ts
import mongoose, { Document, Schema, Types } from 'mongoose';

export interface ISection extends Document {
  title: string;
  description: string;
  type: 'multiple-choice' | 'negotiation' | 'ethical-dilemma' | 'email' | 'video' | 'behavioral';
  timeLimit?: number; // in seconds
  questions: Types.ObjectId[];
  day: 1 | 2;
  order: number;
  // other fields...
}

const SectionSchema = new Schema<ISection>({
  title: {
    type: String,
    required: true,
  },
  description: {
    type: String,
    required: true,
  },
  type: {
    type: String,
    enum: ['multiple-choice', 'negotiation', 'ethical-dilemma', 'email', 'video', 'behavioral'],
    required: true,
  },
  timeLimit: {
    type: Number,
  },
  questions: [{
    type: Schema.Types.ObjectId,
    ref: 'Question',
  }],
  day: {
    type: Number,
    enum: [1, 2],
    required: true,
  },
  order: {
    type: Number,
    required: true,
  },
}, {
  timestamps: true,
});

export const Section = mongoose.model<ISection>('Section', SectionSchema);

// src/models/Question.ts
import mongoose, { Document, Schema } from 'mongoose';

export interface IQuestion extends Document {
  type: 'multiple-choice' | 'text' | 'video' | 'forced-choice' | 'likert' | 'open-ended';
  content: string;
  options?: string[];
  correctOption?: number; // For multiple-choice
  scoringRubric?: {
    criteria: string;
    levels: {
      score: number;
      description: string;
    }[];
  };
  // other fields...
}

const QuestionSchema = new Schema<IQuestion>({
  type: {
    type: String,
    enum: ['multiple-choice', 'text', 'video', 'forced-choice', 'likert', 'open-ended'],
    required: true,
  },
  content: {
    type: String,
    required: true,
  },
  options: [{
    type: String,
  }],
  correctOption: {
    type: Number,
  },
  scoringRubric: {
    criteria: String,
    levels: [{
      score: Number,
      description: String,
    }],
  },
}, {
  timestamps: true,
});

export const Question = mongoose.model<IQuestion>('Question', QuestionSchema);

// src/models/Answer.ts
import mongoose, { Document, Schema, Types } from 'mongoose';

export interface IAnswer extends Document {
  user: Types.ObjectId;
  question: Types.ObjectId;
  section: Types.ObjectId;
  session: Types.ObjectId;
  value: string | number | boolean | string[];
  videoUrl?: string;
  score?: number;
  scoredBy?: Types.ObjectId;
  scoringNotes?: string;
  // other fields...
}

const AnswerSchema = new Schema<IAnswer>({
  user: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true,
  },
  question: {
    type: Schema.Types.ObjectId,
    ref: 'Question',
    required: true,
  },
  section: {
    type: Schema.Types.ObjectId,
    ref: 'Section',
    required: true,
  },
  session: {
    type: Schema.Types.ObjectId,
    ref: 'TestSession',
    required: true,
  },
  value: {
    type: Schema.Types.Mixed,
    required: true,
  },
  videoUrl: {
    type: String,
  },
  score: {
    type: Number,
  },
  scoredBy: {
    type: Schema.Types.ObjectId,
    ref: 'User',
  },
  scoringNotes: {
    type: String,
  },
}, {
  timestamps: true,
});

export const Answer = mongoose.model<IAnswer>('Answer', AnswerSchema);

## Authentication & Authorization

### JWT Implementation

Use JWT for authentication:

```typescript
// src/utils/jwt.ts
import jwt from 'jsonwebtoken';
import { IUser } from '../models/User';

const JWT_SECRET = process.env.JWT_SECRET || 'development-secret';
const JWT_EXPIRES_IN = '1d';
const JWT_REFRESH_EXPIRES_IN = '7d';

export const generateTokens = (user: IUser) => {
  const payload = {
    userId: user._id,
    email: user.email,
    role: user.role,
  };
  
  // Access token (short-lived)
  const accessToken = jwt.sign(payload, JWT_SECRET, {
    expiresIn: JWT_EXPIRES_IN,
  });
  
  // Refresh token (longer-lived)
  const refreshToken = jwt.sign(payload, JWT_SECRET, {
    expiresIn: JWT_REFRESH_EXPIRES_IN,
  });
  
  return { accessToken, refreshToken };
};

export const verifyToken = (token: string) => {
  try {
    return jwt.verify(token, JWT_SECRET) as jwt.JwtPayload & {
      userId: string;
      email: string;
      role: string;
    };
  } catch (error) {
    throw new Error('Invalid token');
  }
};
```

### Authentication Middleware

```typescript
// src/middleware/auth.ts
import { Request, Response, NextFunction } from 'express';
import { verifyToken } from '../utils/jwt';

// Extend Express Request type
declare global {
  namespace Express {
    interface Request {
      user?: {
        userId: string;
        email: string;
        role: string;
      };
    }
  }
}

export const authenticate = (req: Request, res: Response, next: NextFunction) => {
  // Get token from headers
  const authHeader = req.headers.authorization;
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({
      success: false,
      error: {
        code: 'UNAUTHORIZED',
        message: 'Authentication required',
      },
    });
  }
  
  const token = authHeader.split(' ')[1];
  
  try {
    // Verify token
    const decoded = verifyToken(token);
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(401).json({
      success: false,
      error: {
        code: 'INVALID_TOKEN',
        message: 'Invalid or expired token',
      },
    });
  }
};

// Role-based authorization
export const authorize = (roles: string[]) => {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.user) {
      return res.status(401).json({
        success: false,
        error: {
          code: 'UNAUTHORIZED',
          message: 'Authentication required',
        },
      });
    }
    
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({
        success: false,
        error: {
          code: 'FORBIDDEN',
          message: 'Insufficient permissions',
        },
      });
    }
    
    next();
  };
};
```

## File Storage

### S3 Integration for Video Uploads

```typescript
// src/services/s3Service.ts
import { S3Client, PutObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import { v4 as uuidv4 } from 'uuid';

const s3Client = new S3Client({
  region: process.env.AWS_REGION || 'us-east-1',
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID || '',
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || '',
  },
});

const BUCKET_NAME = process.env.S3_BUCKET_NAME || 'quiet-light-test-videos';

export const uploadVideo = async (videoBuffer: Buffer, userId: string, questionId: string): Promise<string> => {
  const fileKey = `videos/${userId}/${questionId}/${uuidv4()}.webm`;
  
  const command = new PutObjectCommand({
    Bucket: BUCKET_NAME,
    Key: fileKey,
    Body: videoBuffer,
    ContentType: 'video/webm',
  });
  
  await s3Client.send(command);
  
  return fileKey;
};

export const getVideoUrl = async (fileKey: string): Promise<string> => {
  const command = new GetObjectCommand({
    Bucket: BUCKET_NAME,
    Key: fileKey,
  });
  
  // Generate a signed URL that expires in 1 hour
  return getSignedUrl(s3Client, command, { expiresIn: 3600 });
};
```

## Controller Patterns

### Controller Structure

Follow this pattern for controllers:

```typescript
// src/controllers/authController.ts
import { Request, Response } from 'express';
import { User } from '../models/User';
import { generateTokens } from '../utils/jwt';
import { catchAsync } from '../utils/catchAsync';

export const login = catchAsync(async (req: Request, res: Response) => {
  const { email, password } = req.body;
  
  // Find user with password
  const user = await User.findOne({ email }).select('+password');
  
  if (!user || !(await user.comparePassword(password))) {
    return res.status(401).json({
      success: false,
      error: {
        code: 'INVALID_CREDENTIALS',
        message: 'Invalid email or password',
      },
    });
  }
  
  // Generate tokens
  const { accessToken, refreshToken } = generateTokens(user);
  
  // Remove password from user object
  user.password = undefined as any;
  
  return res.status(200).json({
    success: true,
    data: {
      user,
      tokens: {
        accessToken,
        refreshToken,
      },
    },
  });
});

export const refreshToken = catchAsync(async (req: Request, res: Response) => {
  const { refreshToken } = req.body;
  
  // Verify refresh token
  const decoded = verifyToken(refreshToken);
  
  // Find user
  const user = await User.findById(decoded.userId);
  
  if (!user) {
    return res.status(401).json({
      success: false,
      error: {
        code: 'INVALID_TOKEN',
        message: 'Invalid refresh token',
      },
    });
  }
  
  // Generate new tokens
  const tokens = generateTokens(user);
  
  return res.status(200).json({
    success: true,
    data: {
      tokens,
    },
  });
});
```

### Error Handling Helper

```typescript
// src/utils/catchAsync.ts
import { Request, Response, NextFunction } from 'express';

export const catchAsync = (fn: Function) => {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};
```

## Error Handling

### Global Error Handler

```typescript
// src/middleware/errorHandler.ts
import { Request, Response, NextFunction } from 'express';
import mongoose from 'mongoose';

export const errorHandler = (err: any, req: Request, res: Response, next: NextFunction) => {
  console.error('Error:', err);
  
  // Default error
  let statusCode = 500;
  let errorCode = 'SERVER_ERROR';
  let message = 'An unexpected error occurred';
  let details = undefined;
  
  // Mongoose validation error
  if (err instanceof mongoose.Error.ValidationError) {
    statusCode = 400;
    errorCode = 'VALIDATION_ERROR';
    message = 'Validation failed';
    details = Object.values(err.errors).map(error => ({
      field: error.path,
      message: error.message,
    }));
  }
  
  // Mongoose duplicate key error
  if (err.code === 11000) {
    statusCode = 400;
    errorCode = 'DUPLICATE_KEY';
    message = 'A record with this value already exists';
    const field = Object.keys(err.keyValue)[0];
    details = [{ field, message: `${field} already exists` }];
  }
  
  // JWT errors
  if (err.name === 'JsonWebTokenError') {
    statusCode = 401;
    errorCode = 'INVALID_TOKEN';
    message = 'Invalid token';
  }
  
  if (err.name === 'TokenExpiredError') {
    statusCode = 401;
    errorCode = 'EXPIRED_TOKEN';
    message = 'Token has expired';
  }
  
  // Custom API errors
  if (err.statusCode && err.code) {
    statusCode = err.statusCode;
    errorCode = err.code;
    message = err.message;
    details = err.details;
  }
  
  return res.status(statusCode).json({
    success: false,
    error: {
      code: errorCode,
      message,
      details,
    },
  });
};

// Custom API Error class
export class ApiError extends Error {
  statusCode: number;
  code: string;
  details?: any[];
  
  constructor(statusCode: number, code: string, message: string, details?: any[]) {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
    this.details = details;
    
    Error.captureStackTrace(this, this.constructor);
  }
  
  static badRequest(message: string, code = 'BAD_REQUEST', details?: any[]) {
    return new ApiError(400, code, message, details);
  }
  
  static unauthorized(message: string, code = 'UNAUTHORIZED', details?: any[]) {
    return new ApiError(401, code, message, details);
  }
  
  static forbidden(message: string, code = 'FORBIDDEN', details?: any[]) {
    return new ApiError(403, code, message, details);
  }
  
  static notFound(message: string, code = 'NOT_FOUND', details?: any[]) {
    return new ApiError(404, code, message, details);
  }
  
  static internal(message: string, code = 'SERVER_ERROR', details?: any[]) {
    return new ApiError(500, code, message, details);
  }
}
```

## Testing Backend

### Jest and Supertest Setup

```typescript
// src/tests/setup.ts
import mongoose from 'mongoose';
import { MongoMemoryServer } from 'mongodb-memory-server';

let mongoServer: MongoMemoryServer;

beforeAll(async () => {
  mongoServer = await MongoMemoryServer.create();
  const uri = mongoServer.getUri();
  await mongoose.connect(uri);
});

afterAll(async () => {
  await mongoose.disconnect();
  await mongoServer.stop();
});

afterEach(async () => {
  const collections = mongoose.connection.collections;
  for (const key in collections) {
    await collections[key].deleteMany({});
  }
});
```

### Controller Tests

```typescript
// src/tests/controllers/authController.test.ts
import request from 'supertest';
import app from '../../app';
import { User } from '../../models/User';

describe('Auth Controller', () => {
  beforeEach(async () => {
    await User.create({
      email: 'test@example.com',
      password: 'password123',
      firstName: 'Test',
      lastName: 'User',
      role: 'candidate',
    });
  });
  
  describe('POST /api/v1/auth/login', () => {
    it('should login with valid credentials', async () => {
      const res = await request(app)
        .post('/api/v1/auth/login')
        .send({
          email: 'test@example.com',
          password: 'password123',
        });
      
      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);
      expect(res.body.data.tokens).toHaveProperty('accessToken');
      expect(res.body.data.tokens).toHaveProperty('refreshToken');
      expect(res.body.data.user).toHaveProperty('email', 'test@example.com');
      expect(res.body.data.user).not.toHaveProperty('password');
    });
    
    it('should return 401 with invalid credentials', async () => {
      const res = await request(app)
        .post('/api/v1/auth/login')
        .send({
          email: 'test@example.com',
          password: 'wrongpassword',
        });
      
      expect(res.status).toBe(401);
      expect(res.body.success).toBe(false);
      expect(res.body.error).toHaveProperty('code', 'INVALID_CREDENTIALS');
    });
  });
});
```

## API Documentation

### Swagger Setup

```typescript
// src/config/swagger.ts
import swaggerJsdoc from 'swagger-jsdoc';
import swaggerUi from 'swagger-ui-express';
import { Express } from 'express';

const options = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'Quiet Light Advisor Aptitude Test API',
      version: '1.0.0',
      description: 'API for the Quiet Light Advisor Aptitude Test platform',
    },
    servers: [
      {
        url: '/api/v1',
        description: 'Development server',
      },
    ],
    components: {
      securitySchemes: {
        bearerAuth: {
          type: 'http',
          scheme: 'bearer',
          bearerFormat: 'JWT',
        },
      },
    },
    security: [
      {
        bearerAuth: [],
      },
    ],
  },
  apis: ['./src/routes/*.ts', './src/models/*.ts'],
};

const specs = swaggerJsdoc(options);

export const setupSwagger = (app: Express) => {
  app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(specs));
};
```

## Security Best Practices

### Security Middleware

```typescript
// src/middleware/security.ts
import { Express } from 'express';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import cors from 'cors';
import xss from 'xss-clean';
import hpp from 'hpp';

export const setupSecurity = (app: Express) => {
  // Set security headers
  app.use(helmet());
  
  // Enable CORS
  app.use(cors({
    origin: process.env.CORS_ORIGIN || '*',
    credentials: true,
  }));
  
  // Rate limiting
  const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // limit each IP to 100 requests per windowMs
    standardHeaders: true,
    legacyHeaders: false,
  });
  app.use('/api', limiter);
  
  // Data sanitization against XSS
  app.use(xss());
  
  // Prevent parameter pollution
  app.use(hpp());
};
```

## Environment Configuration

### Environment Variables Structure

Create a `.env.example` file with this structure:

```
# Server
NODE_ENV=development
PORT=5000
API_VERSION=v1
API_PREFIX=/api

# Database
MONGODB_URI=mongodb://localhost:27017/quiet-light-test
MONGODB_USER=
MONGODB_PASSWORD=

# Authentication
JWT_SECRET=your-secret-key-here
JWT_EXPIRES_IN=1d
JWT_REFRESH_EXPIRES_IN=7d

# AWS S3
AWS_REGION=us-east-1
AWS_ACCESS_KEY_ID=your-access-key
AWS_SECRET_ACCESS_KEY=your-secret-key
S3_BUCKET_NAME=quiet-light-test-videos

# CORS
CORS_ORIGIN=http://localhost:3000
```

## Application Structure

```
src/
├── config/               # Configuration files
│   ├── database.ts       # MongoDB configuration
│   ├── swagger.ts        # API documentation
│   └── express.ts        # Express configuration
├── controllers/          # Request handlers
│   ├── authController.ts
│   ├── userController.ts
│   ├── testController.ts
│   └── ...
├── middleware/           # Middleware functions
│   ├── auth.ts           # Authentication middleware
│   ├── errorHandler.ts   # Global error handler
│   └── validation.ts     # Request validation
├── models/               # Database schemas
│   ├── User.ts
│   ├── TestSession.ts
│   ├── Section.ts
│   └── ...
├── routes/               # API routes
│   ├── auth.ts
│   ├── users.ts
│   ├── testSessions.ts
│   └── ...
├── services/             # Business logic
│   ├── authService.ts
│   ├── testService.ts
│   ├── s3Service.ts
│   └── ...
├── types/                # TypeScript type definitions
│   ├── express.d.ts      # Express type extensions
│   └── ...
├── utils/                # Utility functions
│   ├── jwt.ts            # JWT helpers
│   ├── catchAsync.ts     # Async error handling
│   └── ...
├── app.ts                # Express app setup
└── server.ts             # Entry point
```

## Server Setup

```typescript
// src/app.ts
import express from 'express';
import { setupSecurity } from './middleware/security';
import { setupSwagger } from './config/swagger';
import { errorHandler } from './middleware/errorHandler';
import authRoutes from './routes/auth';
import userRoutes from './routes/users';
import testSessionRoutes from './routes/testSessions';
import sectionRoutes from './routes/sections';
import questionRoutes from './routes/questions';

const app = express();

// Body parser
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Security middleware
setupSecurity(app);

// API routes
const apiPrefix = process.env.API_PREFIX || '/api';
const apiVersion = process.env.API_VERSION || 'v1';
const baseUrl = `${apiPrefix}/${apiVersion}`;

app.use(`${baseUrl}/auth`, authRoutes);
app.use(`${baseUrl}/users`, userRoutes);
app.use(`${baseUrl}/test-sessions`, testSessionRoutes);
app.use(`${baseUrl}/sections`, sectionRoutes);
app.use(`${baseUrl}/questions`, questionRoutes);

// API documentation
setupSwagger(app);

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({
    success: false,
    error: {
      code: 'NOT_FOUND',
      message: 'Resource not found',
    },
  });
});

// Global error handler
app.use(errorHandler);

export default app;
```

```typescript
// src/server.ts
import dotenv from 'dotenv';
dotenv.config();

import app from './app';
import { connectDB } from './config/database';

const PORT = process.env.PORT || 5000;

// Connect to database
connectDB()
  .then(() => {
    console.log('Connected to MongoDB');
    
    // Start server
    app.listen(PORT, () => {
      console.log(`Server running on port ${PORT}`);
    });
  })
  .catch((err) => {
    console.error('Database connection failed', err);
    process.exit(1);
  });

// Handle unhandled rejections
process.on('unhandledRejection', (err) => {
  console.error('Unhandled rejection', err);
  process.exit(1);
});
```

## Deployment Considerations

### Docker Setup

Create a `Dockerfile`:

```dockerfile
FROM node:20-alpine

WORKDIR /usr/src/app

# Copy package files and install dependencies
COPY package*.json ./
RUN npm ci --only=production

# Copy application code
COPY dist/ ./dist/

# Set environment variables
ENV NODE_ENV=production
ENV PORT=5000

# Expose port
EXPOSE 5000

# Start application
CMD ["node", "dist/server.js"]
```

Create a `.dockerignore` file:

```
node_modules
npm-debug.log
.git
.github
.vscode
.env
.env.*
*.md
test
coverage
```

### Docker Compose for Local Development

Create a `docker-compose.yml` file:

```yaml
version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile.dev
    ports:
      - "5000:5000"
    volumes:
      - ./src:/usr/src/app/src
      - ./nodemon.json:/usr/src/app/nodemon.json
    environment:
      - NODE_ENV=development
      - MONGODB_URI=mongodb://mongo:27017/quiet-light-test
    depends_on:
      - mongo
    command: npm run dev
  
  mongo:
    image: mongo:6
    ports:
      - "27017:27017"
    volumes:
      - mongo-data:/data/db

volumes:
  mongo-data:
```

Create a `Dockerfile.dev` for development:

```dockerfile
FROM node:20-alpine

WORKDIR /usr/src/app

COPY package*.json ./
RUN npm install

COPY . .

EXPOSE 5000

CMD ["npm", "run", "dev"]
```

## CI/CD Pipeline

### GitHub Actions Workflow

Create a `.github/workflows/ci.yml` file:

```yaml
name: CI/CD Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Lint
        run: npm run lint
      
      - name: Build
        run: npm run build
      
      - name: Test
        run: npm test
      
      - name: Upload build artifacts
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: actions/upload-artifact@v3
        with:
          name: build
          path: dist/
  
  deploy:
    needs: build-and-test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v3
        with:
          name: build
          path: dist/
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: yourusername/quiet-light-test:latest
      
      # Add deployment steps for your hosting platform here
```

## Performance Optimization

### Database Indexing

Add appropriate indexes to schemas:

```typescript
// Example: Add indexes to User schema
UserSchema.index({ email: 1 }, { unique: true });

// Example: Add indexes to TestSession schema
TestSessionSchema.index({ user: 1, day: 1 });
TestSessionSchema.index({ status: 1 });

// Example: Add indexes to Answer schema
AnswerSchema.index({ user: 1, question: 1 }, { unique: true });
AnswerSchema.index({ session: 1 });
AnswerSchema.index({ section: 1 });
```

### Query Optimization

Use lean queries for read operations:

```typescript
// Instead of
const user = await User.findById(userId);

// Use lean() for better performance
const user = await User.findById(userId).lean();
```

Implement pagination for list endpoints:

```typescript
// src/controllers/userController.ts
export const getUsers = catchAsync(async (req: Request, res: Response) => {
  const page = parseInt(req.query.page as string) || 1;
  const limit = parseInt(req.query.limit as string) || 10;
  const skip = (page - 1) * limit;
  
  const users = await User.find()
    .skip(skip)
    .limit(limit)
    .sort({ createdAt: -1 })
    .lean();
  
  const total = await User.countDocuments();
  
  return res.status(200).json({
    success: true,
    data: users,
    meta: {
      page,
      limit,
      total,
      pages: Math.ceil(total / limit),
    },
  });
});
```

## Logging

### Winston Logger Setup

```typescript
// src/utils/logger.ts
import winston from 'winston';

const logger = winston.createLogger({
  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.splat(),
    winston.format.json()
  ),
  defaultMeta: { service: 'api' },
  transports: [
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      ),
    }),
  ],
});

// Add file transports in production
if (process.env.NODE_ENV === 'production') {
  logger.add(new winston.transports.File({ 
    filename: 'logs/error.log',
    level: 'error',
    maxsize: 10485760, // 10MB
    maxFiles: 5,
  }));
  
  logger.add(new winston.transports.File({ 
    filename: 'logs/combined.log',
    maxsize: 10485760, // 10MB
    maxFiles: 5,
  }));
}

export default logger;
```

### Request Logging Middleware

```typescript
// src/middleware/requestLogger.ts
import { Request, Response, NextFunction } from 'express';
import logger from '../utils/logger';

export const requestLogger = (req: Request, res: Response, next: NextFunction) => {
  // Generate request ID
  const requestId = req.headers['x-request-id'] || `req-${Date.now()}`;
  
  // Log request
  logger.info(`Request: ${req.method} ${req.originalUrl}`, {
    requestId,
    method: req.method,
    url: req.originalUrl,
    ip: req.ip,
    userId: req.user?.userId,
  });
  
  // Capture response time
  const start = Date.now();
  
  // Log response
  res.on('finish', () => {
    const duration = Date.now() - start;
    
    const logMethod = res.statusCode >= 400 ? logger.error : logger.info;
    
    logMethod(`Response: ${res.statusCode} ${duration}ms`, {
      requestId,
      statusCode: res.statusCode,
      duration,
      userId: req.user?.userId,
    });
  });
  
  next();
};
```

## Monitoring

### Health Check Endpoint

```typescript
// src/routes/health.ts
import express from 'express';
import mongoose from 'mongoose';

const router = express.Router();

router.get('/', async (req, res) => {
  const healthcheck = {
    uptime: process.uptime(),
    message: 'OK',
    timestamp: Date.now(),
    database: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected',
  };
  
  try {
    res.status(200).json(healthcheck);
  } catch (error) {
    healthcheck.message = 'ERROR';
    res.status(503).json(healthcheck);
  }
});

export default router;
```

Add to app.ts:

```typescript
import healthRouter from './routes/health';
app.use('/health', healthRouter);
```---
# Frontend Implementation Rules

## Component Design Principles

### UI Components

All UI components should:
- Be fully typed with TypeScript
- Accept consistent props patterns
- Include comprehensive prop documentation
- Support accessibility features
- Handle loading, error, and empty states
- Be responsive by default

### Component Structure Example

```tsx
// Button.tsx
import React from 'react';
import { cn } from '@/lib/utils';
import { ButtonProps } from './Button.types';

/**
 * Primary button component for user interactions
 */
export const Button: React.FC<ButtonProps> = ({
  variant = 'default',
  size = 'md',
  children,
  className,
  disabled,
  isLoading,
  ...props
}) => {
  // Implementation
};
```

```tsx
// Button.types.ts
export interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  /** Visual variant of the button */
  variant?: 'default' | 'primary' | 'secondary' | 'outline' | 'ghost';
  /** Size of the button */
  size?: 'sm' | 'md' | 'lg';
  /** Whether the button shows a loading state */
  isLoading?: boolean;
}
```

## Tailwind CSS Implementation

### Class Organization

Organize Tailwind classes in a consistent order:

```tsx
// Recommended ordering
<div className={cn(
  // Layout (display, position)
  "flex absolute inset-0",
  // Box model (width, height, padding, margin)
  "w-full h-12 p-4 my-2",
  // Typography
  "text-base font-medium text-gray-800",
  // Visual (colors, backgrounds, borders)
  "bg-white border border-gray-200 rounded-md shadow-sm",
  // Misc (transitions, animations, cursor)
  "transition-all duration-200 cursor-pointer",
  // Responsive variants
  "sm:flex-row md:w-auto lg:p-6",
  // State variants
  "hover:bg-gray-50 focus:ring-2 focus:ring-blue-500",
  // Custom classes
  className
)}/>
```

### Custom Utility Function

Use the utility function below for merging Tailwind classes:

```tsx
// src/lib/utils.ts
import { clsx, type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';

/**
 * Combines multiple class values into a single className string,
 * handling Tailwind class conflicts appropriately
 */
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
```

### Quiet Light Brand Colors

Configure Tailwind with the Quiet Light brand colors:

```js
// tailwind.config.js
module.exports = {
  theme: {
    extend: {
      colors: {
        'brand': {
          'navy': '#0a1a3d',    // Bespoke Navy (Primary)
          'mint': '#b8f7b8',    // Renew Mint (Secondary)
          'blue': '#297dde',    // Nomad Blue (Secondary)
          'teal': '#66e0f5',    // Freedom Teal (Accent)
          'green': '#36a157',   // Constant Green (Accent)
        },
      },
    },
  },
}
```

## Form Implementation

### Form Structure

Use React Hook Form with Zod validation:

```tsx
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';
import { Button } from '@/components/ui/button';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { Input } from '@/components/ui/input';

// Define form schema with Zod
const formSchema = z.object({
  email: z.string().email({ message: 'Please enter a valid email address' }),
  password: z.string().min(8, { message: 'Password must be at least 8 characters' }),
});

// Infer TypeScript type from schema
type FormValues = z.infer<typeof formSchema>;

export function LoginForm() {
  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      email: '',
      password: '',
    },
  });

  function onSubmit(values: FormValues) {
    // Handle form submission
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        <FormField
          control={form.control}
          name="email"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Email</FormLabel>
              <FormControl>
                <Input placeholder="email@example.com" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        {/* Additional form fields */}
        <Button type="submit" disabled={form.formState.isSubmitting}>
          {form.formState.isSubmitting ? 'Logging in...' : 'Login'}
        </Button>
      </form>
    </Form>
  );
}
```

## Video Recording Implementation

Use the following pattern for video recording components:

```tsx
import React, { useState, useRef } from 'react';
import { Button } from '@/components/ui/button';
import { useVideoRecorder } from '@/hooks/useVideoRecorder';
import { cn } from '@/lib/utils';

export function VideoRecorder({ onRecordingComplete, maxDuration = 120 }) {
  const {
    videoBlob,
    isRecording,
    timeRemaining,
    startRecording,
    stopRecording,
    error,
  } = useVideoRecorder({ maxDuration });
  
  const [isReviewing, setIsReviewing] = useState(false);
  const videoRef = useRef<HTMLVideoElement>(null);
  
  // Handle recording completion
  const handleComplete = async () => {
    if (videoBlob) {
      onRecordingComplete(videoBlob);
    }
  };
  
  // Handle retry recording
  const handleRetry = () => {
    setIsReviewing(false);
  };
  
  // After recording stops, show review
  React.useEffect(() => {
    if (videoBlob && !isRecording) {
      setIsReviewing(true);
      if (videoRef.current) {
        videoRef.current.src = URL.createObjectURL(videoBlob);
      }
    }
  }, [videoBlob, isRecording]);
  
  return (
    <div className="flex flex-col items-center space-y-4">
      {error && (
        <div className="w-full p-3 text-white bg-red-500 rounded-md">
          {error.message}
        </div>
      )}
      
      <div className={cn(
        "relative w-full aspect-video bg-gray-100 rounded-lg overflow-hidden",
        isRecording && "ring-2 ring-red-500"
      )}>
        {isReviewing ? (
          <video ref={videoRef} className="w-full h-full" controls />
        ) : (
          <video id="preview" className="w-full h-full mirror" autoPlay muted />
        )}
        
        {isRecording && (
          <div className="absolute top-4 right-4 px-2 py-1 text-sm font-medium text-white bg-red-500 rounded-md animate-pulse">
            Recording: {Math.floor(timeRemaining / 60)}:{(timeRemaining % 60).toString().padStart(2, '0')}
          </div>
        )}
      </div>
      
      <div className="flex items-center space-x-4">
        {!isRecording && !isReviewing && (
          <Button 
            onClick={startRecording}
            variant="primary"
            size="lg"
          >
            Start Recording
          </Button>
        )}
        
        {isRecording && (
          <Button 
            onClick={stopRecording}
            variant="destructive"
            size="lg"
          >
            Stop Recording
          </Button>
        )}
        
        {isReviewing && (
          <>
            <Button 
              onClick={handleRetry}
              variant="outline"
              size="lg"
            >
              Record Again
            </Button>
            <Button 
              onClick={handleComplete}
              variant="primary"
              size="lg"
            >
              Submit Response
            </Button>
          </>
        )}
      </div>
    </div>
  );
}
```

## Custom Hook Implementation

Create reusable hooks for common functionality:

```tsx
// useVideoRecorder.ts
import { useState, useEffect, useRef } from 'react';

interface VideoRecorderOptions {
  maxDuration?: number; // in seconds
}

interface VideoRecorderReturn {
  isRecording: boolean;
  timeRemaining: number;
  videoBlob: Blob | null;
  startRecording: () => Promise<void>;
  stopRecording: () => void;
  error: Error | null;
}

export function useVideoRecorder({ maxDuration = 120 }: VideoRecorderOptions = {}): VideoRecorderReturn {
  const [isRecording, setIsRecording] = useState(false);
  const [timeRemaining, setTimeRemaining] = useState(maxDuration);
  const [videoBlob, setVideoBlob] = useState<Blob | null>(null);
  const [error, setError] = useState<Error | null>(null);
  
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const streamRef = useRef<MediaStream | null>(null);
  const chunksRef = useRef<Blob[]>([]);
  const timerRef = useRef<number | null>(null);
  
  // Clean up resources when component unmounts
  useEffect(() => {
    return () => {
      if (streamRef.current) {
        streamRef.current.getTracks().forEach(track => track.stop());
      }
      if (timerRef.current) {
        window.clearInterval(timerRef.current);
      }
    };
  }, []);
  
  const startRecording = async () => {
    try {
      chunksRef.current = [];
      setVideoBlob(null);
      setError(null);
      setTimeRemaining(maxDuration);
      
      const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      streamRef.current = stream;
      
      // Connect stream to preview element
      const videoElement = document.getElementById('preview') as HTMLVideoElement;
      if (videoElement) {
        videoElement.srcObject = stream;
      }
      
      // Create media recorder
      const mediaRecorder = new MediaRecorder(stream);
      mediaRecorderRef.current = mediaRecorder;
      
      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          chunksRef.current.push(event.data);
        }
      };
      
      mediaRecorder.onstop = () => {
        const videoBlob = new Blob(chunksRef.current, { type: 'video/webm' });
        setVideoBlob(videoBlob);
        
        if (streamRef.current) {
          streamRef.current.getTracks().forEach(track => track.stop());
        }
        
        if (timerRef.current) {
          window.clearInterval(timerRef.current);
        }
      };
      
      // Start recording
      mediaRecorder.start(1000);
      setIsRecording(true);
      
      // Set timer for countdown
      timerRef.current = window.setInterval(() => {
        setTimeRemaining(prev => {
          if (prev <= 1) {
            stopRecording();
            return 0;
          }
          return prev - 1;
        });
      }, 1000);
      
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Failed to start recording'));
    }
  };
  
  const stopRecording = () => {
    if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {
      mediaRecorderRef.current.stop();
    }
    
    setIsRecording(false);
    
    if (timerRef.current) {
      window.clearInterval(timerRef.current);
    }
  };
  
  return {
    isRecording,
    timeRemaining,
    videoBlob,
    startRecording,
    stopRecording,
    error,
  };
}
```

## Data Fetching Pattern

Use React Query for data fetching:

```tsx
// src/services/api.ts
import axios from 'axios';

const api = axios.create({
  baseURL: '/api',
  headers: {
    'Content-Type': 'application/json',
  },
});

// Add request interceptor for authentication
api.interceptors.request.use((config) => {
  const token = localStorage.getItem('auth_token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// Add response interceptor for error handling
api.interceptors.response.use(
  (response) => response,
  (error) => {
    // Handle authentication errors
    if (error.response?.status === 401) {
      // Redirect to login or refresh token
    }
    return Promise.reject(error);
  }
);

export default api;
```

```tsx
// src/services/testService.ts
import api from './api';

export interface Question {
  id: string;
  type: 'multiple-choice' | 'text' | 'video' | 'forced-choice' | 'likert' | 'open-ended';
  content: string;
  options?: string[];
  // Other properties...
}

export const testService = {
  // Get test session for the current day
  getTestSession: async () => {
    const { data } = await api.get('/test-sessions/current');
    return data;
  },
  
  // Get questions for a specific test section
  getQuestions: async (sectionId: string) => {
    const { data } = await api.get<Question[]>(`/sections/${sectionId}/questions`);
    return data;
  },
  
  // Submit answers for a test section
  submitAnswers: async (sectionId: string, answers: Record<string, any>) => {
    const { data } = await api.post(`/sections/${sectionId}/answers`, answers);
    return data;
  },
  
  // Upload video response
  uploadVideoResponse: async (questionId: string, videoBlob: Blob) => {
    const formData = new FormData();
    formData.append('video', videoBlob, 'response.webm');
    
    const { data } = await api.post(`/questions/${questionId}/video-response`, formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    });
    
    return data;
  },
};
```

```tsx
// src/hooks/useQuestions.ts
import { useQuery } from '@tanstack/react-query';
import { testService } from '@/services/testService';

export function useQuestions(sectionId: string) {
  return useQuery({
    queryKey: ['questions', sectionId],
    queryFn: () => testService.getQuestions(sectionId),
    staleTime: 1000 * 60 * 5, // 5 minutes
  });
}
```

## Layout and Page Structure

Use a consistent page structure:

```tsx
// src/pages/TestSessionPage.tsx
import React from 'react';
import { useQuery } from '@tanstack/react-query';
import { useParams, useNavigate } from 'react-router-dom';
import { testService } from '@/services/testService';
import { PageLayout } from '@/components/layout/PageLayout';
import { TestHeader } from '@/components/test/TestHeader';
import { QuestionContainer } from '@/components/test/QuestionContainer';
import { LoadingSpinner } from '@/components/ui/LoadingSpinner';
import { Button } from '@/components/ui/button';
import { useToast } from '@/hooks/useToast';

export function TestSessionPage() {
  const { sectionId } = useParams<{ sectionId: string }>();
  const navigate = useNavigate();
  const { toast } = useToast();
  
  const { data: sessionData, isLoading: isSessionLoading, error: sessionError } = useQuery({
    queryKey: ['test-session'],
    queryFn: testService.getTestSession,
  });
  
  const { data: questions, isLoading: isQuestionsLoading, error: questionsError } = 
    useQuestions(sectionId || '');
  
  const isLoading = isSessionLoading || isQuestionsLoading;
  const error = sessionError || questionsError;
  
  if (isLoading) {
    return (
      <PageLayout>
        <div className="flex items-center justify-center h-screen">
          <LoadingSpinner size="lg" />
        </div>
      </PageLayout>
    );
  }
  
  if (error) {
    return (
      <PageLayout>
        <div className="flex flex-col items-center justify-center h-screen">
          <h2 className="mb-4 text-xl font-bold text-red-600">An error occurred</h2>
          <p className="mb-6 text-gray-600">{error instanceof Error ? error.message : 'Failed to load test session'}</p>
          <Button 
            onClick={() => window.location.reload()}
            variant="outline"
          >
            Retry
          </Button>
        </div>
      </PageLayout>
    );
  }
  
  return (
    <PageLayout>
      <TestHeader 
        title={sessionData?.currentSection?.title || 'Test Session'} 
        timeRemaining={sessionData?.currentSection?.timeRemaining}
        progress={sessionData?.progress}
      />
      
      <div className="container py-8">
        {questions && <QuestionContainer questions={questions} sectionId={sectionId || ''} />}
      </div>
    </PageLayout>
  );
}
```

## Responsive Design

Follow these patterns for responsive design:

```tsx
// Mobile-first approach
<div className="
  p-4 text-sm 
  sm:p-6 sm:text-base
  md:p-8 md:text-lg
  lg:p-10 lg:text-xl
">
  Content
</div>

// For complex layouts
<div className="
  flex flex-col items-center space-y-4
  md:flex-row md:items-start md:space-y-0 md:space-x-4
">
  <div className="w-full md:w-1/3">Sidebar</div>
  <div className="w-full md:w-2/3">Main Content</div>
</div>

// For hiding/showing elements
<div className="hidden md:block">Desktop Only</div>
<div className="block md:hidden">Mobile Only</div>
```

## Testing Components

Use Jest and React Testing Library:

```tsx
// Button.test.tsx
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from './Button';

describe('Button component', () => {
  it('renders correctly with default props', () => {
    render(<Button>Click me</Button>);
    const button = screen.getByRole('button', { name: /click me/i });
    expect(button).toBeInTheDocument();
    expect(button).toHaveClass('bg-brand-navy'); // Primary color
  });
  
  it('handles clicks correctly', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>Click me</Button>);
    const button = screen.getByRole('button', { name: /click me/i });
    fireEvent.click(button);
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
  
  it('displays loading state when isLoading is true', () => {
    render(<Button isLoading>Click me</Button>);
    expect(screen.getByRole('status')).toBeInTheDocument(); // Loading spinner
    expect(screen.getByText('Loading...')).toBeInTheDocument();
  });
  
  it('is disabled when disabled prop is true', () => {
    render(<Button disabled>Click me</Button>);
    expect(screen.getByRole('button', { name: /click me/i })).toBeDisabled();
  });
  
  it('applies custom className', () => {
    render(<Button className="custom-class">Click me</Button>);
    expect(screen.getByRole('button', { name: /click me/i })).toHaveClass('custom-class');
  });
});
```---
# Project Rules

## Project Overview

This project is a sophisticated web application for administering the Quiet Light Advisor Aptitude Test, a two-day assessment for potential business brokers. It evaluates candidates' knowledge, negotiation skills, ethical reasoning, communication abilities, and honesty through various question formats.

## Technology Stack

### Frontend
- **Framework**: React.js with TypeScript
- **Component Library**: Shadcn UI for customizable, accessible components
- **Styling**: Tailwind CSS exclusively (avoid raw CSS unless absolutely necessary)
- **Animations**: Framer Motion for transitions and interactions
- **Data Visualization**: D3.js for charts and visualizations
- **State Management**: React Context API and custom hooks

### Backend
- **Runtime**: Node.js with Express
- **Database**: MongoDB
- **Authentication**: JWT
- **File Storage**: AWS S3 for video responses

## Coding Standards

### General
- Use TypeScript for all code
- Follow the DRY (Don't Repeat Yourself) principle
- Write unit tests for critical functionality
- Include JSDocs for all public functions and components

### Naming Conventions
- **Variables and Functions**: camelCase
- **Components**: PascalCase
- **Types and Interfaces**: PascalCase
- **Constants**: UPPER_SNAKE_CASE
- **Files**: Follow component name (e.g., `Button.tsx`, `Button.types.ts`)

### Component Structure
- Use functional components exclusively
- Organize imports logically: React, third-party, internal
- Define types/interfaces at the top of the file or in separate `.types.ts` files
- Extract complex logic into custom hooks
- Keep components focused on a single responsibility

### File Organization
```
src/
├── components/
│   ├── ui/          # Shadcn UI components
│   ├── layout/      # Layout components
│   ├── forms/       # Form-related components
│   ├── test/        # Test-specific components
│   └── common/      # Shared components
├── hooks/           # Custom React hooks
├── pages/           # Page components
├── services/        # API services
├── types/           # Shared TypeScript types
├── utils/           # Utility functions
└── styles/          # Global styles and Tailwind config
```

### Styling Guidelines
- Use Tailwind CSS classes exclusively
- Group related Tailwind classes logically:
  1. Layout (display, position)
  2. Box model (width, height, padding, margin)
  3. Typography (font, text)
  4. Visual (colors, backgrounds, borders)
  5. Misc (transitions, animations)
- For dynamic styling, use `clsx` or `tailwind-merge`
- Use Quiet Light's brand colors:
  - Primary: Bespoke Navy (`#0a1a3d`)
  - Secondary: Renew Mint (`#b8f7b8`), Nomad Blue (`#297dde`)
  - Accent: Freedom Teal (`#66e0f5`), Constant Green (`#36a157`)

### State Management
- Use React Context for global state (authentication, test progress)
- Use React Query for server state management
- Use local state for component-specific concerns
- Consider using Zustand for more complex state requirements

### API Calls
- Create service modules for API interactions
- Use React Query for data fetching and caching
- Handle loading, error, and success states consistently
- Implement retry logic for transient failures

### Forms
- Use React Hook Form for form management
- Implement Zod for schema validation
- Create reusable form components
- Handle form submission errors gracefully

### Testing
- Write unit tests for critical functionality
- Use React Testing Library for component tests
- Mock API calls and external dependencies
- Test both happy paths and error scenarios

### Performance
- Implement code splitting for larger bundles
- Use React.memo for expensive components
- Optimize renders with useMemo and useCallback where appropriate
- Lazy load components and routes
- Implement virtualization for long lists

### Accessibility
- Ensure all interactive elements are keyboard accessible
- Use appropriate ARIA attributes
- Maintain proper heading hierarchy
- Ensure sufficient color contrast
- Support screen readers

### Security
- Sanitize all user inputs
- Implement proper authentication and authorization
- Use HTTPS for all API calls
- Secure storage of sensitive data
- Implement CSRF protection

## Features Implementation

### User Authentication
- Implement secure login with JWT
- Store tokens securely (HTTP-only cookies)
- Handle session expiration gracefully
- Implement role-based access control

### Test Administration
- Track candidate progress across sessions
- Enforce time limits on relevant sections
- Support session resumption
- Implement automatic submission when time expires

### Question Types
- Implement all required question types:
  - Multiple choice
  - Text response
  - Video recording
  - Forced-choice
  - Likert scale
  - Open-ended text

### Video Recording
- Use browser APIs for video capture
- Implement countdown and recording indicators
- Allow preview before submission
- Handle device permissions gracefully
- Compress videos before upload when possible

### Scoring System
- Implement automatic scoring for objective questions
- Create interfaces for manual scoring of subjective responses
- Calculate section and overall scores
- Generate visual representations of results

### Analytics
- Track completion rates and time spent
- Identify commonly missed questions
- Analyze consistency across responses
- Generate performance trends

## Commit Guidelines
- Use conventional commit messages:
  - feat: New feature
  - fix: Bug fix
  - docs: Documentation
  - style: Formatting changes
  - refactor: Code refactoring
  - test: Adding or updating tests
  - chore: Maintenance tasks
- Keep commits focused on a single concern
- Include ticket/issue numbers in commit messages when applicable

## Code Review Standards
- Verify adherence to project structure and naming conventions
- Check for TypeScript errors and proper type definitions
- Ensure comprehensive test coverage for new features
- Verify accessibility compliance
- Check for performance considerations
- Confirm responsive design implementation---
# Database Migrations Rules

## Overview

This document outlines the rules and best practices for database migrations in the Quiet Light Advisor Aptitude Test application. Migrations are critical for maintaining database schema changes over time and ensuring consistent database states across environments.

## Migration Implementation

### Migration Framework

Use MongoDB's native migration capabilities with the `migrate-mongo` package:

```typescript
// Install the package
// npm install migrate-mongo --save-dev
```

### Migration Directory Structure

```
migrations/
├── migrate-mongo-config.js  # Migration configuration
└── migrations/              # Migration files
    ├── 20250401000000-create-users.js
    ├── 20250401000100-create-test-sessions.js
    └── ...
```

### Configuration

```javascript
// migrate-mongo-config.js
const config = {
  mongodb: {
    url: process.env.MONGODB_URI || 'mongodb://localhost:27017',
    databaseName: 'quiet-light-test',
    options: {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    }
  },
  migrationsDir: 'migrations/migrations',
  changelogCollectionName: 'changelog',
  migrationFileExtension: '.js',
  useFileHash: false,
  moduleSystem: 'commonjs',
};

module.exports = config;
```

## Migration File Format

Each migration should follow this pattern:

```javascript
// migrations/migrations/20250401000000-create-users.js
module.exports = {
  async up(db, client) {
    // Create collections
    await db.createCollection('users', {
      validator: {
        $jsonSchema: {
          bsonType: 'object',
          required: ['email', 'password', 'firstName', 'lastName', 'role'],
          properties: {
            email: {
              bsonType: 'string',
              description: 'Email must be a string and is required'
            },
            password: {
              bsonType: 'string',
              description: 'Password must be a string and is required'
            },
            firstName: {
              bsonType: 'string',
              description: 'First name must be a string and is required'
            },
            lastName: {
              bsonType: 'string',
              description: 'Last name must be a string and is required'
            },
            role: {
              enum: ['candidate', 'admin'],
              description: 'Role must be either candidate or admin and is required'
            }
          }
        }
      }
    });

    // Create indexes
    await db.collection('users').createIndex({ email: 1 }, { unique: true });
    
    // Insert initial data if needed
    await db.collection('users').insertOne({
      email: 'admin@quietlight.com',
      // Note: In a real migration, this would be a hashed password
      password: '$2b$10$X7o.KQCXJjnBkZNjwXJ4QOPyRfZCDOKSnWG.7r3ExyYUKVEirTUVu', // "password123"
      firstName: 'Admin',
      lastName: 'User',
      role: 'admin',
      createdAt: new Date(),
      updatedAt: new Date()
    });
  },

  async down(db, client) {
    // Drop indexes
    await db.collection('users').dropIndex({ email: 1 });
    
    // Drop collections
    await db.collection('users').drop();
  }
};
```

## Migration Best Practices

### General Guidelines

1. **Atomic Changes**: Each migration should make one logical change to the database schema.
2. **Reversibility**: Always implement the `down` function to allow rollbacks.
3. **Idempotency**: Migrations should be idempotent - running the same migration multiple times should not cause errors.
4. **Testing**: Test migrations in development environment before running in production.
5. **Comments**: Include clear comments explaining the purpose of the migration and any potential risks.

### Naming Convention

Use a timestamp-based naming convention for migration files:

```
YYYYMMDDHHMMSS-descriptive-name.js
```

For example:
```
20250401000000-create-users.js
20250401000100-create-test-sessions.js
```

### Data Migrations

When migrating data (not just schema), follow these guidelines:

1. **Batching**: Process data in batches to avoid memory issues with large datasets.
2. **Progress Logging**: Log progress for long-running migrations.
3. **Error Handling**: Implement robust error handling to prevent partial migrations.

Example data migration:

```javascript
// migrations/migrations/20250402000000-add-scores-to-answers.js
module.exports = {
  async up(db, client) {
    const cursor = db.collection('answers').find({ score: { $exists: false } });
    
    let count = 0;
    const batchSize = 100;
    
    let batch = [];
    
    while (await cursor.hasNext()) {
      const answer = await cursor.next();
      batch.push({
        updateOne: {
          filter: { _id: answer._id },
          update: { $set: { score: 0, scoredBy: null, scoringNotes: '' } }
        }
      });
      
      count++;
      
      if (batch.length === batchSize) {
        console.log(`Processing batch of ${batch.length} documents (${count} total)`);
        await db.collection('answers').bulkWrite(batch);
        batch = [];
      }
    }
    
    if (batch.length > 0) {
      console.log(`Processing final batch of ${batch.length} documents (${count} total)`);
      await db.collection('answers').bulkWrite(batch);
    }
    
    console.log(`Completed migration: ${count} documents updated`);
  },

  async down(db, client) {
    await db.collection('answers').updateMany(
      {},
      { $unset: { score: "", scoredBy: "", scoringNotes: "" } }
    );
  }
};
```

## Index Changes

When changing indexes, consider performance implications:

```javascript
// migrations/migrations/20250403000000-optimize-test-session-queries.js
module.exports = {
  async up(db, client) {
    // Create index
    console.log('Creating compound index on testSessions collection...');
    await db.collection('testSessions').createIndex(
      { user: 1, status: 1, day: 1 },
      { name: 'user_status_day_idx' }
    );
    console.log('Index created successfully');
  },

  async down(db, client) {
    // Drop index
    console.log('Dropping compound index from testSessions collection...');
    await db.collection('testSessions').dropIndex('user_status_day_idx');
    console.log('Index dropped successfully');
  }
};
```

## Schema Validation Changes

When updating schema validation rules:

```javascript
// migrations/migrations/20250404000000-update-question-validation.js
module.exports = {
  async up(db, client) {
    await db.command({
      collMod: 'questions',
      validator: {
        $jsonSchema: {
          bsonType: 'object',
          required: ['type', 'content'],
          properties: {
            type: {
              enum: [
                'multiple-choice', 
                'text', 
                'video', 
                'forced-choice', 
                'likert', 
                'open-ended'
              ],
              description: 'Type must be one of the predefined values and is required'
            },
            content: {
              bsonType: 'string',
              description: 'Content must be a string and is required'
            },
            options: {
              bsonType: 'array',
              description: 'Options must be an array if provided',
              items: {
                bsonType: 'string'
              }
            },
            correctOption: {
              bsonType: 'int',
              description: 'CorrectOption must be an integer if provided'
            },
            scoringRubric: {
              bsonType: 'object',
              description: 'ScoringRubric must be an object if provided',
              properties: {
                criteria: { bsonType: 'string' },
                levels: {
                  bsonType: 'array',
                  items: {
                    bsonType: 'object',
                    required: ['score', 'description'],
                    properties: {
                      score: { bsonType: 'int' },
                      description: { bsonType: 'string' }
                    }
                  }
                }
              }
            }
          }
        }
      },
      validationLevel: 'moderate', // Use 'moderate' to apply validation only to new or updated documents
      validationAction: 'error'    // Reject invalid documents
    });
  },

  async down(db, client) {
    // Revert to previous validation schema
    await db.command({
      collMod: 'questions',
      validator: {
        $jsonSchema: {
          bsonType: 'object',
          required: ['type', 'content'],
          properties: {
            type: {
              enum: ['multiple-choice', 'text', 'video', 'forced-choice', 'likert', 'open-ended'],
              description: 'Type must be one of the predefined values and is required'
            },
            content: {
              bsonType: 'string',
              description: 'Content must be a string and is required'
            }
          }
        }
      }
    });
  }
};
```

## Running Migrations

Add the following scripts to your `package.json`:

```json
{
  "scripts": {
    "migrate:create": "migrate-mongo create",
    "migrate:up": "migrate-mongo up",
    "migrate:down": "migrate-mongo down",
    "migrate:status": "migrate-mongo status"
  }
}
```

### Usage Examples

1. **Create a new migration**:
   ```
   npm run migrate:create -- add-new-field-to-users
   ```

2. **Apply pending migrations**:
   ```
   npm run migrate:up
   ```

3. **Roll back the last migration**:
   ```
   npm run migrate:down
   ```

4. **Check migration status**:
   ```
   npm run migrate:status
   ```

## Integration with Deployment Process

Integrate migrations into your CI/CD pipeline:

```yaml
# In your GitHub Actions workflow or other CI/CD configuration
- name: Run database migrations
  run: npm run migrate:up
  env:
    MONGODB_URI: ${{ secrets.MONGODB_URI }}
```

## Troubleshooting

### Handling Failed Migrations

If a migration fails:

1. Check the error message and logs
2. Fix the issue in the migration file
3. If the migration was partially applied, you might need to:
   - Manually clean up any partial changes
   - Create a new migration that completes the intended changes
   - Update the changelog collection to reflect the corrected state

### Manual Changelog Manipulation

In extreme cases, you may need to manipulate the changelog collection directly:

```javascript
// Example: Mark a problematic migration as applied
db.changelog.insertOne({
  fileName: '20250401000000-create-users.js',
  appliedAt: new Date()
});

// Example: Remove a migration entry to allow re-running
db.changelog.deleteOne({
  fileName: '20250401000000-create-users.js'
});
```

## Seed Data for Development

Create a separate script for seeding development data:

```javascript
// scripts/seedDevelopmentData.js
const mongoose = require('mongoose');
const bcrypt = require('bcrypt');
require('dotenv').config();

const seedData = async () => {
  try {
    // Connect to database
    await mongoose.connect(process.env.MONGODB_URI);
    console.log('Connected to MongoDB');

    // Import models
    const User = require('../dist/models/User').User;
    const TestSession = require('../dist/models/TestSession').TestSession;
    const Section = require('../dist/models/Section').Section;
    const Question = require('../dist/models/Question').Question;

    // Clear existing data
    await User.deleteMany({});
    await TestSession.deleteMany({});
    await Section.deleteMany({});
    await Question.deleteMany({});

    console.log('Cleared existing data');

    // Create admin user
    const adminPassword = await bcrypt.hash('admin123', 10);
    const admin = await User.create({
      email: 'admin@quietlight.com',
      password: adminPassword,
      firstName: 'Admin',
      lastName: 'User',
      role: 'admin'
    });

    console.log('Created admin user');

    // Create test user
    const userPassword = await bcrypt.hash('test123', 10);
    const user = await User.create({
      email: 'test@example.com',
      password: userPassword,
      firstName: 'Test',
      lastName: 'User',
      role: 'candidate'
    });

    console.log('Created test user');

    // Create sections
    const foundationalKnowledgeSection = await Section.create({
      title: 'Foundational Knowledge',
      description: 'Test your understanding of key concepts in business brokerage.',
      type: 'multiple-choice',
      day: 1,
      order: 1,
      timeLimit: 1800 // 30 minutes
    });

    const negotiationSection = await Section.create({
      title: 'Timed Negotiation Simulation',
      description: 'Respond to a high-pressure negotiation scenario.',
      type: 'negotiation',
      day: 1,
      order: 2,
      timeLimit: 300 // 5 minutes
    });

    console.log('Created test sections');

    // Create sample questions
    const question1 = await Question.create({
      type: 'multiple-choice',
      content: 'When evaluating a content site that receives 75% of its traffic from Google organic search, what recommendations would you give the owner to increase its value?',
      options: [
        'Develop alternative traffic sources like social media and email marketing',
        'Focus on increasing the site\'s Domain Authority through aggressive link building',
        'Create more content targeting higher-volume keywords to improve traffic',
        'Implement display advertising to diversify beyond affiliate revenue',
        'Invest in paid traffic to reduce dependency on organic search'
      ],
      correctOption: 0
    });

    const question2 = await Question.create({
      type: 'negotiation',
      content: 'A buyer unexpectedly demands a 20% price cut two days before closing. The seller is furious and wants to walk away. How would you handle this situation?',
      scoringRubric: {
        criteria: 'Strategic Thinking Under Pressure',
        levels: [
          { score: 1, description: 'Reactive response without clear strategy' },
          { score: 2, description: 'Basic strategy with limited leverage identification' },
          { score: 3, description: 'Adequate strategy addressing most key concerns' },
          { score: 4, description: 'Strong strategy with good leverage point identification' },
          { score: 5, description: 'Exceptional strategy with multiple leverage points and contingencies' }
        ]
      }
    });

    console.log('Created sample questions');

    // Link questions to sections
    await Section.findByIdAndUpdate(
      foundationalKnowledgeSection._id,
      { $push: { questions: question1._id } }
    );

    await Section.findByIdAndUpdate(
      negotiationSection._id,
      { $push: { questions: question2._id } }
    );

    console.log('Linked questions to sections');

    // Create test session
    await TestSession.create({
      user: user._id,
      day: 1,
      status: 'pending',
      sections: [foundationalKnowledgeSection._id, negotiationSection._id],
      progress: {
        sectionsCompleted: 0,
        totalSections: 2
      }
    });

    console.log('Created test session');

    console.log('Seed data created successfully');
  } catch (error) {
    console.error('Error seeding data:', error);
  } finally {
    await mongoose.connection.close();
    console.log('Database connection closed');
  }
};

seedData();
```

Add to package.json:

```json
{
  "scripts": {
    "seed:dev": "node scripts/seedDevelopmentData.js"
  }
}
```
